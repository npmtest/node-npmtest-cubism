{"/home/travis/build/npmtest/node-npmtest-cubism/test.js":"/* istanbul instrument in package npmtest_cubism */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cubism/lib.npmtest_cubism.js":"/* istanbul instrument in package npmtest_cubism */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cubism = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cubism = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cubism/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cubism && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cubism */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cubism\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cubism.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cubism.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cubism.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cubism.__dirname + '/lib.npmtest_cubism.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/index.js":"// Sorry for polluting your global namespace!\nd3 = require(\"d3\");\n\nmodule.exports = require(\"./cubism.v1\").cubism;\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/cubism.v1.js":"(function(exports){\nvar cubism = exports.cubism = {version: \"1.6.0\"};\nvar cubism_id = 0;\nfunction cubism_identity(d) { return d; }\ncubism.option = function(name, defaultValue) {\n  var values = cubism.options(name);\n  return values.length ? values[0] : defaultValue;\n};\n\ncubism.options = function(name, defaultValues) {\n  var options = location.search.substring(1).split(\"&\"),\n      values = [],\n      i = -1,\n      n = options.length,\n      o;\n  while (++i < n) {\n    if ((o = options[i].split(\"=\"))[0] == name) {\n      values.push(decodeURIComponent(o[1]));\n    }\n  }\n  return values.length || arguments.length < 2 ? values : defaultValues;\n};\ncubism.context = function() {\n  var context = new cubism_context,\n      step = 1e4, // ten seconds, in milliseconds\n      size = 1440, // four hours at ten seconds, in pixels\n      start0, stop0, // the start and stop for the previous change event\n      start1, stop1, // the start and stop for the next prepare event\n      serverDelay = 5e3,\n      clientDelay = 5e3,\n      event = d3.dispatch(\"prepare\", \"beforechange\", \"change\", \"focus\"),\n      scale = context.scale = d3.time.scale().range([0, size]),\n      timeout,\n      focus;\n\n  function update() {\n    var now = Date.now();\n    stop0 = new Date(Math.floor((now - serverDelay - clientDelay) / step) * step);\n    start0 = new Date(stop0 - size * step);\n    stop1 = new Date(Math.floor((now - serverDelay) / step) * step);\n    start1 = new Date(stop1 - size * step);\n    scale.domain([start0, stop0]);\n    return context;\n  }\n\n  context.start = function() {\n    if (timeout) clearTimeout(timeout);\n    var delay = +stop1 + serverDelay - Date.now();\n\n    // If we're too late for the first prepare event, skip it.\n    if (delay < clientDelay) delay += step;\n\n    timeout = setTimeout(function prepare() {\n      stop1 = new Date(Math.floor((Date.now() - serverDelay) / step) * step);\n      start1 = new Date(stop1 - size * step);\n      event.prepare.call(context, start1, stop1);\n\n      setTimeout(function() {\n        scale.domain([start0 = start1, stop0 = stop1]);\n        event.beforechange.call(context, start1, stop1);\n        event.change.call(context, start1, stop1);\n        event.focus.call(context, focus);\n      }, clientDelay);\n\n      timeout = setTimeout(prepare, step);\n    }, delay);\n    return context;\n  };\n\n  context.stop = function() {\n    timeout = clearTimeout(timeout);\n    return context;\n  };\n\n  timeout = setTimeout(context.start, 10);\n\n  // Set or get the step interval in milliseconds.\n  // Defaults to ten seconds.\n  context.step = function(_) {\n    if (!arguments.length) return step;\n    step = +_;\n    return update();\n  };\n\n  // Set or get the context size (the count of metric values).\n  // Defaults to 1440 (four hours at ten seconds).\n  context.size = function(_) {\n    if (!arguments.length) return size;\n    scale.range([0, size = +_]);\n    return update();\n  };\n\n  // The server delay is the amount of time we wait for the server to compute a\n  // metric. This delay may result from clock skew or from delays collecting\n  // metrics from various hosts. Defaults to 4 seconds.\n  context.serverDelay = function(_) {\n    if (!arguments.length) return serverDelay;\n    serverDelay = +_;\n    return update();\n  };\n\n  // The client delay is the amount of additional time we wait to fetch those\n  // metrics from the server. The client and server delay combined represent the\n  // age of the most recent displayed metric. Defaults to 1 second.\n  context.clientDelay = function(_) {\n    if (!arguments.length) return clientDelay;\n    clientDelay = +_;\n    return update();\n  };\n\n  // Sets the focus to the specified index, and dispatches a \"focus\" event.\n  context.focus = function(i) {\n    event.focus.call(context, focus = i);\n    return context;\n  };\n\n  // Add, remove or get listeners for events.\n  context.on = function(type, listener) {\n    if (arguments.length < 2) return event.on(type);\n\n    event.on(type, listener);\n\n    // Notify the listener of the current start and stop time, as appropriate.\n    // This way, metrics can make requests for data immediately,\n    // and likewise the axis can display itself synchronously.\n    if (listener != null) {\n      if (/^prepare(\\.|$)/.test(type)) listener.call(context, start1, stop1);\n      if (/^beforechange(\\.|$)/.test(type)) listener.call(context, start0, stop0);\n      if (/^change(\\.|$)/.test(type)) listener.call(context, start0, stop0);\n      if (/^focus(\\.|$)/.test(type)) listener.call(context, focus);\n    }\n\n    return context;\n  };\n\n  d3.select(window).on(\"keydown.context-\" + ++cubism_id, function() {\n    switch (!d3.event.metaKey && d3.event.keyCode) {\n      case 37: // left\n        if (focus == null) focus = size - 1;\n        if (focus > 0) context.focus(--focus);\n        break;\n      case 39: // right\n        if (focus == null) focus = size - 2;\n        if (focus < size - 1) context.focus(++focus);\n        break;\n      default: return;\n    }\n    d3.event.preventDefault();\n  });\n\n  return update();\n};\n\nfunction cubism_context() {}\n\nvar cubism_contextPrototype = cubism.context.prototype = cubism_context.prototype;\n\ncubism_contextPrototype.constant = function(value) {\n  return new cubism_metricConstant(this, +value);\n};\ncubism_contextPrototype.cube = function(host) {\n  if (!arguments.length) host = \"\";\n  var source = {},\n      context = this;\n\n  source.metric = function(expression) {\n    return context.metric(function(start, stop, step, callback) {\n      d3.json(host + \"/1.0/metric\"\n          + \"?expression=\" + encodeURIComponent(expression)\n          + \"&start=\" + cubism_cubeFormatDate(start)\n          + \"&stop=\" + cubism_cubeFormatDate(stop)\n          + \"&step=\" + step, function(data) {\n        if (!data) return callback(new Error(\"unable to load data\"));\n        callback(null, data.map(function(d) { return d.value; }));\n      });\n    }, expression += \"\");\n  };\n\n  // Returns the Cube host.\n  source.toString = function() {\n    return host;\n  };\n\n  return source;\n};\n\nvar cubism_cubeFormatDate = d3.time.format.iso;\n/* librato (http://dev.librato.com/v1/post/metrics) source\n * If you want to see an example of how to use this source, check: https://gist.github.com/drio/5792680\n */\ncubism_contextPrototype.librato = function(user, token) {\n  var source      = {},\n      context     = this;\n      auth_string = \"Basic \" + btoa(user + \":\" + token);\n      avail_rsts  = [ 1, 60, 900, 3600 ];\n\n  /* Given a step, find the best librato resolution to use.\n   *\n   * Example:\n   *\n   * (s) : cubism step\n   *\n   * avail_rsts   1 --------------- 60 --------------- 900 ---------------- 3600\n   *                                |    (s)            |\n   *                                |                   |\n   *                              [low_res             top_res]\n   *\n   * return: low_res (60)\n   */\n  function find_ideal_librato_resolution(step) {\n    var highest_res = avail_rsts[0],\n        lowest_res  = avail_rsts[avail_rsts.length]; // high and lowest available resolution from librato\n\n    /* If step is outside the highest or lowest librato resolution, pick them and we are done */\n    if (step >= lowest_res)\n      return lowest_res;\n\n    if (step <= highest_res)\n      return highest_res;\n\n    /* If not, find in what resolution interval the step lands. */\n    var iof, top_res, i;\n    for (i=step; i<=lowest_res; i++) {\n      iof = avail_rsts.indexOf(i);\n      if (iof > -1) {\n        top_res = avail_rsts[iof];\n        break;\n      }\n    }\n\n    var low_res;\n    for (i=step; i>=highest_res; i--) {\n      iof = avail_rsts.indexOf(i);\n      if (iof > -1) {\n        low_res = avail_rsts[iof];\n        break;\n      }\n    }\n\n    /* What's the closest librato resolution given the step ? */\n    return ((top_res-step) < (step-low_res)) ? top_res : low_res;\n  }\n\n  function find_librato_resolution(sdate, edate, step) {\n    var i_size      = edate - sdate,                 // interval size\n        month       = 2419200,\n        week        = 604800,\n        two_days    = 172800,\n        ideal_res;\n\n    if (i_size > month)\n      return 3600;\n\n    ideal_res = find_ideal_librato_resolution(step);\n\n    /*\n     * Now we have the ideal resolution, but due to the retention policies at librato, maybe we have\n     * to use a higher resolution.\n     * http://support.metrics.librato.com/knowledgebase/articles/66838-understanding-metrics-roll-ups-retention-and-grap\n     */\n    if (i_size > week && ideal_res < 900)\n      return 900;\n    else if (i_size > two_days && ideal_res < 60)\n      return 60;\n    else\n      return ideal_res;\n  }\n\n  /* All the logic to query the librato API is here */\n  var librato_request = function(composite) {\n    var url_prefix  = \"https://metrics-api.librato.com/v1/metrics\";\n\n    function make_url(sdate, edate, step) {\n      var params    = \"compose=\"     + composite +\n                      \"&start_time=\" + sdate     +\n                      \"&end_time=\"   + edate     +\n                      \"&resolution=\" + find_librato_resolution(sdate, edate, step);\n      return url_prefix + \"?\" + params;\n    }\n\n    /*\n     * We are most likely not going to get the same number of measurements\n     * cubism expects for a particular context: We have to perform down/up\n     * sampling\n     */\n    function down_up_sampling(isdate, iedate, step, librato_mm) {\n      var av = [];\n\n      for (i=isdate; i<=iedate; i+=step) {\n        var int_mes = [];\n        while (librato_mm.length && librato_mm[0].measure_time <= i) {\n          int_mes.push(librato_mm.shift().value);\n        }\n\n        var v;\n        if (int_mes.length) { /* Compute the average */\n          v = int_mes.reduce(function(a, b) { return a + b }) / int_mes.length;\n        } else { /* No librato values on interval */\n          v = (av.length) ? av[av.length-1] : 0;\n        }\n        av.push(v);\n      }\n\n      return av;\n    }\n\n    request = {};\n\n    request.fire = function(isdate, iedate, step, callback_done) {\n      var a_values = []; /* Store partial values from librato */\n\n      /*\n       * Librato has a limit in the number of measurements we get back in a request (100).\n       * We recursively perform requests to the API to ensure we have all the data points\n       * for the interval we are working on.\n       */\n      function actual_request(full_url) {\n        d3.json(full_url)\n          .header(\"X-Requested-With\", \"XMLHttpRequest\")\n          .header(\"Authorization\", auth_string)\n          .header(\"Librato-User-Agent\", 'cubism/' + cubism.version)\n          .get(function (error, data) { /* Callback; data available */\n            if (!error) {\n              if (data.measurements.length === 0) {\n                return\n              }\n              data.measurements[0].series.forEach(function(o) { a_values.push(o); });\n\n              var still_more_values = 'query' in data && 'next_time' in data.query;\n              if (still_more_values) {\n                actual_request(make_url(data.query.next_time, iedate, step));\n              } else {\n                var a_adjusted = down_up_sampling(isdate, iedate, step, a_values);\n                callback_done(a_adjusted);\n              }\n            }\n          });\n      }\n\n      actual_request(make_url(isdate, iedate, step));\n    };\n\n    return request;\n  };\n\n  /*\n   * The user will use this method to create a cubism source (librato in this case)\n   * and call .metric() as necessary to create metrics.\n   */\n  source.metric = function(m_composite) {\n    return context.metric(function(start, stop, step, callback) {\n      /* All the librato logic is here; .fire() retrieves the metrics' data */\n      librato_request(m_composite)\n        .fire(cubism_libratoFormatDate(start),\n              cubism_libratoFormatDate(stop),\n              cubism_libratoFormatDate(step),\n              function(a_values) { callback(null, a_values); });\n\n      }, m_composite += \"\");\n    };\n\n  /* This is not used when the source is librato */\n  source.toString = function() {\n    return \"librato\";\n  };\n\n  return source;\n};\n\nvar cubism_libratoFormatDate = function(time) {\n  return Math.floor(time / 1000);\n};\ncubism_contextPrototype.graphite = function(host) {\n  if (!arguments.length) host = \"\";\n  var source = {},\n      context = this;\n\n  source.metric = function(expression) {\n    var sum = \"sum\";\n\n    var metric = context.metric(function(start, stop, step, callback) {\n      var target = expression;\n\n      // Apply the summarize, if necessary.\n      if (step !== 1e4) target = \"summarize(\" + target + \",'\"\n          + (!(step % 36e5) ? step / 36e5 + \"hour\" : !(step % 6e4) ? step / 6e4 + \"min\" : step / 1e3 + \"sec\")\n          + \"','\" + sum + \"')\";\n\n      d3.text(host + \"/render?format=raw\"\n          + \"&target=\" + encodeURIComponent(\"alias(\" + target + \",'')\")\n          + \"&from=\" + cubism_graphiteFormatDate(start - 2 * step) // off-by-two?\n          + \"&until=\" + cubism_graphiteFormatDate(stop - 1000), function(text) {\n        if (!text) return callback(new Error(\"unable to load data\"));\n        callback(null, cubism_graphiteParse(text));\n      });\n    }, expression += \"\");\n\n    metric.summarize = function(_) {\n      sum = _;\n      return metric;\n    };\n\n    return metric;\n  };\n\n  source.find = function(pattern, callback) {\n    d3.json(host + \"/metrics/find?format=completer\"\n        + \"&query=\" + encodeURIComponent(pattern), function(result) {\n      if (!result) return callback(new Error(\"unable to find metrics\"));\n      callback(null, result.metrics.map(function(d) { return d.path; }));\n    });\n  };\n\n  // Returns the graphite host.\n  source.toString = function() {\n    return host;\n  };\n\n  return source;\n};\n\n// Graphite understands seconds since UNIX epoch.\nfunction cubism_graphiteFormatDate(time) {\n  return Math.floor(time / 1000);\n}\n\n// Helper method for parsing graphite's raw format.\nfunction cubism_graphiteParse(text) {\n  var i = text.indexOf(\"|\"),\n      meta = text.substring(0, i),\n      c = meta.lastIndexOf(\",\"),\n      b = meta.lastIndexOf(\",\", c - 1),\n      a = meta.lastIndexOf(\",\", b - 1),\n      start = meta.substring(a + 1, b) * 1000,\n      step = meta.substring(c + 1) * 1000;\n  return text\n      .substring(i + 1)\n      .split(\",\")\n      .slice(1) // the first value is always None?\n      .map(function(d) { return +d; });\n}\ncubism_contextPrototype.gangliaWeb = function(config) {\n  var host = '',\n      uriPathPrefix = '/ganglia2/';\n \n  if (arguments.length) {\n    if (config.host) {\n      host = config.host;\n    }\n\n    if (config.uriPathPrefix) {\n      uriPathPrefix = config.uriPathPrefix;\n\n      /* Add leading and trailing slashes, as appropriate. */\n      if( uriPathPrefix[0] != '/' ) {\n        uriPathPrefix = '/' + uriPathPrefix;\n      }\n\n      if( uriPathPrefix[uriPathPrefix.length - 1] != '/' ) {\n        uriPathPrefix += '/';\n      }\n    }\n  }\n\n  var source = {},\n      context = this;\n\n  source.metric = function(metricInfo) {\n\n    /* Store the members from metricInfo into local variables. */\n    var clusterName = metricInfo.clusterName, \n        metricName = metricInfo.metricName, \n        hostName = metricInfo.hostName,\n        isReport = metricInfo.isReport || false,\n        titleGenerator = metricInfo.titleGenerator ||\n          /* Reasonable (not necessarily pretty) default for titleGenerator. */\n          function(unusedMetricInfo) {\n            /* unusedMetricInfo is, well, unused in this default case. */\n            return ('clusterName:' + clusterName + \n                    ' metricName:' + metricName +\n                    (hostName ? ' hostName:' + hostName : ''));\n          },\n        onChangeCallback = metricInfo.onChangeCallback;\n    \n    /* Default to plain, simple metrics. */\n    var metricKeyName = isReport ? 'g' : 'm';\n\n    var gangliaWebMetric = context.metric(function(start, stop, step, callback) {\n\n      function constructGangliaWebRequestQueryParams() {\n        return ('c=' + clusterName +\n                '&' + metricKeyName + '=' + metricName + \n                (hostName ? '&h=' + hostName : '') + \n                '&cs=' + start/1000 + '&ce=' + stop/1000 + '&step=' + step/1000 + '&graphlot=1');\n      }\n\n      d3.json(host + uriPathPrefix + 'graph.php?' + constructGangliaWebRequestQueryParams(),\n        function(result) {\n          if( !result ) {\n            return callback(new Error(\"Unable to fetch GangliaWeb data\"));\n          }\n\n          callback(null, result[0].data);\n        });\n\n    }, titleGenerator(metricInfo));\n\n    gangliaWebMetric.toString = function() {\n      return titleGenerator(metricInfo);\n    };\n\n    /* Allow users to run their custom code each time a gangliaWebMetric changes.\n     *\n     * TODO Consider abstracting away the naked Cubism call, and instead exposing \n     * a callback that takes in the values array (maybe alongwith the original\n     * start and stop 'naked' parameters), since it's handy to have the entire\n     * dataset at your disposal (and users will likely implement onChangeCallback\n     * primarily to get at this dataset).\n     */\n    if (onChangeCallback) {\n      gangliaWebMetric.on('change', onChangeCallback);\n    }\n\n    return gangliaWebMetric;\n  };\n\n  // Returns the gangliaWeb host + uriPathPrefix.\n  source.toString = function() {\n    return host + uriPathPrefix;\n  };\n\n  return source;\n};\n\nfunction cubism_metric(context) {\n  if (!(context instanceof cubism_context)) throw new Error(\"invalid context\");\n  this.context = context;\n}\n\nvar cubism_metricPrototype = cubism_metric.prototype;\n\ncubism.metric = cubism_metric;\n\ncubism_metricPrototype.valueAt = function() {\n  return NaN;\n};\n\ncubism_metricPrototype.alias = function(name) {\n  this.toString = function() { return name; };\n  return this;\n};\n\ncubism_metricPrototype.extent = function() {\n  var i = 0,\n      n = this.context.size(),\n      value,\n      min = Infinity,\n      max = -Infinity;\n  while (++i < n) {\n    value = this.valueAt(i);\n    if (value < min) min = value;\n    if (value > max) max = value;\n  }\n  return [min, max];\n};\n\ncubism_metricPrototype.on = function(type, listener) {\n  return arguments.length < 2 ? null : this;\n};\n\ncubism_metricPrototype.shift = function() {\n  return this;\n};\n\ncubism_metricPrototype.on = function() {\n  return arguments.length < 2 ? null : this;\n};\n\ncubism_contextPrototype.metric = function(request, name) {\n  var context = this,\n      metric = new cubism_metric(context),\n      id = \".metric-\" + ++cubism_id,\n      start = -Infinity,\n      stop,\n      step = context.step(),\n      size = context.size(),\n      values = [],\n      event = d3.dispatch(\"change\"),\n      listening = 0,\n      fetching;\n\n  // Prefetch new data into a temporary array.\n  function prepare(start1, stop) {\n    var steps = Math.min(size, Math.round((start1 - start) / step));\n    if (!steps || fetching) return; // already fetched, or fetching!\n    fetching = true;\n    steps = Math.min(size, steps + cubism_metricOverlap);\n    var start0 = new Date(stop - steps * step);\n    request(start0, stop, step, function(error, data) {\n      fetching = false;\n      if (error) return console.warn(error);\n      var i = isFinite(start) ? Math.round((start0 - start) / step) : 0;\n      for (var j = 0, m = data.length; j < m; ++j) values[j + i] = data[j];\n      event.change.call(metric, start, stop);\n    });\n  }\n\n  // When the context changes, switch to the new data, ready-or-not!\n  function beforechange(start1, stop1) {\n    if (!isFinite(start)) start = start1;\n    values.splice(0, Math.max(0, Math.min(size, Math.round((start1 - start) / step))));\n    start = start1;\n    stop = stop1;\n  }\n\n  //\n  metric.valueAt = function(i) {\n    return values[i];\n  };\n\n  //\n  metric.shift = function(offset) {\n    return context.metric(cubism_metricShift(request, +offset));\n  };\n\n  //\n  metric.on = function(type, listener) {\n    if (!arguments.length) return event.on(type);\n\n    // If there are no listeners, then stop listening to the context,\n    // and avoid unnecessary fetches.\n    if (listener == null) {\n      if (event.on(type) != null && --listening == 0) {\n        context.on(\"prepare\" + id, null).on(\"beforechange\" + id, null);\n      }\n    } else {\n      if (event.on(type) == null && ++listening == 1) {\n        context.on(\"prepare\" + id, prepare).on(\"beforechange\" + id, beforechange);\n      }\n    }\n\n    event.on(type, listener);\n\n    // Notify the listener of the current start and stop time, as appropriate.\n    // This way, charts can display synchronous metrics immediately.\n    if (listener != null) {\n      if (/^change(\\.|$)/.test(type)) listener.call(context, start, stop);\n    }\n\n    return metric;\n  };\n\n  //\n  if (arguments.length > 1) metric.toString = function() {\n    return name;\n  };\n\n  return metric;\n};\n\n// Number of metric to refetch each period, in case of lag.\nvar cubism_metricOverlap = 6;\n\n// Wraps the specified request implementation, and shifts time by the given offset.\nfunction cubism_metricShift(request, offset) {\n  return function(start, stop, step, callback) {\n    request(new Date(+start + offset), new Date(+stop + offset), step, callback);\n  };\n}\nfunction cubism_metricConstant(context, value) {\n  cubism_metric.call(this, context);\n  value = +value;\n  var name = value + \"\";\n  this.valueOf = function() { return value; };\n  this.toString = function() { return name; };\n}\n\nvar cubism_metricConstantPrototype = cubism_metricConstant.prototype = Object.create(cubism_metric.prototype);\n\ncubism_metricConstantPrototype.valueAt = function() {\n  return +this;\n};\n\ncubism_metricConstantPrototype.extent = function() {\n  return [+this, +this];\n};\nfunction cubism_metricOperator(name, operate) {\n\n  function cubism_metricOperator(left, right) {\n    if (!(right instanceof cubism_metric)) right = new cubism_metricConstant(left.context, right);\n    else if (left.context !== right.context) throw new Error(\"mismatch context\");\n    cubism_metric.call(this, left.context);\n    this.left = left;\n    this.right = right;\n    this.toString = function() { return left + \" \" + name + \" \" + right; };\n  }\n\n  var cubism_metricOperatorPrototype = cubism_metricOperator.prototype = Object.create(cubism_metric.prototype);\n\n  cubism_metricOperatorPrototype.valueAt = function(i) {\n    return operate(this.left.valueAt(i), this.right.valueAt(i));\n  };\n\n  cubism_metricOperatorPrototype.shift = function(offset) {\n    return new cubism_metricOperator(this.left.shift(offset), this.right.shift(offset));\n  };\n\n  cubism_metricOperatorPrototype.on = function(type, listener) {\n    if (arguments.length < 2) return this.left.on(type);\n    this.left.on(type, listener);\n    this.right.on(type, listener);\n    return this;\n  };\n\n  return function(right) {\n    return new cubism_metricOperator(this, right);\n  };\n}\n\ncubism_metricPrototype.add = cubism_metricOperator(\"+\", function(left, right) {\n  return left + right;\n});\n\ncubism_metricPrototype.subtract = cubism_metricOperator(\"-\", function(left, right) {\n  return left - right;\n});\n\ncubism_metricPrototype.multiply = cubism_metricOperator(\"*\", function(left, right) {\n  return left * right;\n});\n\ncubism_metricPrototype.divide = cubism_metricOperator(\"/\", function(left, right) {\n  return left / right;\n});\ncubism_contextPrototype.horizon = function() {\n  var context = this,\n      mode = \"offset\",\n      buffer = document.createElement(\"canvas\"),\n      width = buffer.width = context.size(),\n      height = buffer.height = 30,\n      scale = d3.scale.linear().interpolate(d3.interpolateRound),\n      metric = cubism_identity,\n      extent = null,\n      title = cubism_identity,\n      format = d3.format(\".2s\"),\n      colors = [\"#08519c\",\"#3182bd\",\"#6baed6\",\"#bdd7e7\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"];\n\n  function horizon(selection) {\n\n    selection\n        .on(\"mousemove.horizon\", function() { context.focus(Math.round(d3.mouse(this)[0])); })\n        .on(\"mouseout.horizon\", function() { context.focus(null); });\n\n    selection.append(\"canvas\")\n        .attr(\"width\", width)\n        .attr(\"height\", height);\n\n    selection.append(\"span\")\n        .attr(\"class\", \"title\")\n        .text(title);\n\n    selection.append(\"span\")\n        .attr(\"class\", \"value\");\n\n    selection.each(function(d, i) {\n      var that = this,\n          id = ++cubism_id,\n          metric_ = typeof metric === \"function\" ? metric.call(that, d, i) : metric,\n          colors_ = typeof colors === \"function\" ? colors.call(that, d, i) : colors,\n          extent_ = typeof extent === \"function\" ? extent.call(that, d, i) : extent,\n          start = -Infinity,\n          step = context.step(),\n          canvas = d3.select(that).select(\"canvas\"),\n          span = d3.select(that).select(\".value\"),\n          max_,\n          m = colors_.length >> 1,\n          ready;\n\n      canvas.datum({id: id, metric: metric_});\n      canvas = canvas.node().getContext(\"2d\");\n\n      function change(start1, stop) {\n        canvas.save();\n\n        // compute the new extent and ready flag\n        var extent = metric_.extent();\n        ready = extent.every(isFinite);\n        if (extent_ != null) extent = extent_;\n\n        // if this is an update (with no extent change), copy old values!\n        var i0 = 0, max = Math.max(-extent[0], extent[1]);\n        if (this === context) {\n          if (max == max_) {\n            i0 = width - cubism_metricOverlap;\n            var dx = (start1 - start) / step;\n            if (dx < width) {\n              var canvas0 = buffer.getContext(\"2d\");\n              canvas0.clearRect(0, 0, width, height);\n              canvas0.drawImage(canvas.canvas, dx, 0, width - dx, height, 0, 0, width - dx, height);\n              canvas.clearRect(0, 0, width, height);\n              canvas.drawImage(canvas0.canvas, 0, 0);\n            }\n          }\n          start = start1;\n        }\n\n        // update the domain\n        scale.domain([0, max_ = max]);\n\n        // clear for the new data\n        canvas.clearRect(i0, 0, width - i0, height);\n\n        // record whether there are negative values to display\n        var negative;\n\n        // positive bands\n        for (var j = 0; j < m; ++j) {\n          canvas.fillStyle = colors_[m + j];\n\n          // Adjust the range based on the current band index.\n          var y0 = (j - m + 1) * height;\n          scale.range([m * height + y0, y0]);\n          y0 = scale(0);\n\n          for (var i = i0, n = width, y1; i < n; ++i) {\n            y1 = metric_.valueAt(i);\n            if (y1 <= 0) { negative = true; continue; }\n            if (y1 === undefined) continue;\n            canvas.fillRect(i, y1 = scale(y1), 1, y0 - y1);\n          }\n        }\n\n        if (negative) {\n          // enable offset mode\n          if (mode === \"offset\") {\n            canvas.translate(0, height);\n            canvas.scale(1, -1);\n          }\n\n          // negative bands\n          for (var j = 0; j < m; ++j) {\n            canvas.fillStyle = colors_[m - 1 - j];\n\n            // Adjust the range based on the current band index.\n            var y0 = (j - m + 1) * height;\n            scale.range([m * height + y0, y0]);\n            y0 = scale(0);\n\n            for (var i = i0, n = width, y1; i < n; ++i) {\n              y1 = metric_.valueAt(i);\n              if (y1 >= 0) continue;\n              canvas.fillRect(i, scale(-y1), 1, y0 - scale(-y1));\n            }\n          }\n        }\n\n        canvas.restore();\n      }\n\n      function focus(i) {\n        if (i == null) i = width - 1;\n        var value = metric_.valueAt(i);\n        span.datum(value).text(isNaN(value) ? null : format);\n      }\n\n      // Update the chart when the context changes.\n      context.on(\"change.horizon-\" + id, change);\n      context.on(\"focus.horizon-\" + id, focus);\n\n      // Display the first metric change immediately,\n      // but defer subsequent updates to the canvas change.\n      // Note that someone still needs to listen to the metric,\n      // so that it continues to update automatically.\n      metric_.on(\"change.horizon-\" + id, function(start, stop) {\n        change(start, stop), focus();\n        if (ready) metric_.on(\"change.horizon-\" + id, cubism_identity);\n      });\n    });\n  }\n\n  horizon.remove = function(selection) {\n\n    selection\n        .on(\"mousemove.horizon\", null)\n        .on(\"mouseout.horizon\", null);\n\n    selection.selectAll(\"canvas\")\n        .each(remove)\n        .remove();\n\n    selection.selectAll(\".title,.value\")\n        .remove();\n\n    function remove(d) {\n      d.metric.on(\"change.horizon-\" + d.id, null);\n      context.on(\"change.horizon-\" + d.id, null);\n      context.on(\"focus.horizon-\" + d.id, null);\n    }\n  };\n\n  horizon.mode = function(_) {\n    if (!arguments.length) return mode;\n    mode = _ + \"\";\n    return horizon;\n  };\n\n  horizon.height = function(_) {\n    if (!arguments.length) return height;\n    buffer.height = height = +_;\n    return horizon;\n  };\n\n  horizon.metric = function(_) {\n    if (!arguments.length) return metric;\n    metric = _;\n    return horizon;\n  };\n\n  horizon.scale = function(_) {\n    if (!arguments.length) return scale;\n    scale = _;\n    return horizon;\n  };\n\n  horizon.extent = function(_) {\n    if (!arguments.length) return extent;\n    extent = _;\n    return horizon;\n  };\n\n  horizon.title = function(_) {\n    if (!arguments.length) return title;\n    title = _;\n    return horizon;\n  };\n\n  horizon.format = function(_) {\n    if (!arguments.length) return format;\n    format = _;\n    return horizon;\n  };\n\n  horizon.colors = function(_) {\n    if (!arguments.length) return colors;\n    colors = _;\n    return horizon;\n  };\n\n  return horizon;\n};\ncubism_contextPrototype.comparison = function() {\n  var context = this,\n      width = context.size(),\n      height = 120,\n      scale = d3.scale.linear().interpolate(d3.interpolateRound),\n      primary = function(d) { return d[0]; },\n      secondary = function(d) { return d[1]; },\n      extent = null,\n      title = cubism_identity,\n      formatPrimary = cubism_comparisonPrimaryFormat,\n      formatChange = cubism_comparisonChangeFormat,\n      colors = [\"#9ecae1\", \"#225b84\", \"#a1d99b\", \"#22723a\"],\n      strokeWidth = 1.5;\n\n  function comparison(selection) {\n\n    selection\n        .on(\"mousemove.comparison\", function() { context.focus(Math.round(d3.mouse(this)[0])); })\n        .on(\"mouseout.comparison\", function() { context.focus(null); });\n\n    selection.append(\"canvas\")\n        .attr(\"width\", width)\n        .attr(\"height\", height);\n\n    selection.append(\"span\")\n        .attr(\"class\", \"title\")\n        .text(title);\n\n    selection.append(\"span\")\n        .attr(\"class\", \"value primary\");\n\n    selection.append(\"span\")\n        .attr(\"class\", \"value change\");\n\n    selection.each(function(d, i) {\n      var that = this,\n          id = ++cubism_id,\n          primary_ = typeof primary === \"function\" ? primary.call(that, d, i) : primary,\n          secondary_ = typeof secondary === \"function\" ? secondary.call(that, d, i) : secondary,\n          extent_ = typeof extent === \"function\" ? extent.call(that, d, i) : extent,\n          div = d3.select(that),\n          canvas = div.select(\"canvas\"),\n          spanPrimary = div.select(\".value.primary\"),\n          spanChange = div.select(\".value.change\"),\n          ready;\n\n      canvas.datum({id: id, primary: primary_, secondary: secondary_});\n      canvas = canvas.node().getContext(\"2d\");\n\n      function change(start, stop) {\n        canvas.save();\n        canvas.clearRect(0, 0, width, height);\n\n        // update the scale\n        var primaryExtent = primary_.extent(),\n            secondaryExtent = secondary_.extent(),\n            extent = extent_ == null ? primaryExtent : extent_;\n        scale.domain(extent).range([height, 0]);\n        ready = primaryExtent.concat(secondaryExtent).every(isFinite);\n\n        // consistent overplotting\n        var round = start / context.step() & 1\n            ? cubism_comparisonRoundOdd\n            : cubism_comparisonRoundEven;\n\n        // positive changes\n        canvas.fillStyle = colors[2];\n        for (var i = 0, n = width; i < n; ++i) {\n          var y0 = scale(primary_.valueAt(i)),\n              y1 = scale(secondary_.valueAt(i));\n          if (y0 < y1) canvas.fillRect(round(i), y0, 1, y1 - y0);\n        }\n\n        // negative changes\n        canvas.fillStyle = colors[0];\n        for (i = 0; i < n; ++i) {\n          var y0 = scale(primary_.valueAt(i)),\n              y1 = scale(secondary_.valueAt(i));\n          if (y0 > y1) canvas.fillRect(round(i), y1, 1, y0 - y1);\n        }\n\n        // positive values\n        canvas.fillStyle = colors[3];\n        for (i = 0; i < n; ++i) {\n          var y0 = scale(primary_.valueAt(i)),\n              y1 = scale(secondary_.valueAt(i));\n          if (y0 <= y1) canvas.fillRect(round(i), y0, 1, strokeWidth);\n        }\n\n        // negative values\n        canvas.fillStyle = colors[1];\n        for (i = 0; i < n; ++i) {\n          var y0 = scale(primary_.valueAt(i)),\n              y1 = scale(secondary_.valueAt(i));\n          if (y0 > y1) canvas.fillRect(round(i), y0 - strokeWidth, 1, strokeWidth);\n        }\n\n        canvas.restore();\n      }\n\n      function focus(i) {\n        if (i == null) i = width - 1;\n        var valuePrimary = primary_.valueAt(i),\n            valueSecondary = secondary_.valueAt(i),\n            valueChange = (valuePrimary - valueSecondary) / valueSecondary;\n\n        spanPrimary\n            .datum(valuePrimary)\n            .text(isNaN(valuePrimary) ? null : formatPrimary);\n\n        spanChange\n            .datum(valueChange)\n            .text(isNaN(valueChange) ? null : formatChange)\n            .attr(\"class\", \"value change \" + (valueChange > 0 ? \"positive\" : valueChange < 0 ? \"negative\" : \"\"));\n      }\n\n      // Display the first primary change immediately,\n      // but defer subsequent updates to the context change.\n      // Note that someone still needs to listen to the metric,\n      // so that it continues to update automatically.\n      primary_.on(\"change.comparison-\" + id, firstChange);\n      secondary_.on(\"change.comparison-\" + id, firstChange);\n      function firstChange(start, stop) {\n        change(start, stop), focus();\n        if (ready) {\n          primary_.on(\"change.comparison-\" + id, cubism_identity);\n          secondary_.on(\"change.comparison-\" + id, cubism_identity);\n        }\n      }\n\n      // Update the chart when the context changes.\n      context.on(\"change.comparison-\" + id, change);\n      context.on(\"focus.comparison-\" + id, focus);\n    });\n  }\n\n  comparison.remove = function(selection) {\n\n    selection\n        .on(\"mousemove.comparison\", null)\n        .on(\"mouseout.comparison\", null);\n\n    selection.selectAll(\"canvas\")\n        .each(remove)\n        .remove();\n\n    selection.selectAll(\".title,.value\")\n        .remove();\n\n    function remove(d) {\n      d.primary.on(\"change.comparison-\" + d.id, null);\n      d.secondary.on(\"change.comparison-\" + d.id, null);\n      context.on(\"change.comparison-\" + d.id, null);\n      context.on(\"focus.comparison-\" + d.id, null);\n    }\n  };\n\n  comparison.height = function(_) {\n    if (!arguments.length) return height;\n    height = +_;\n    return comparison;\n  };\n\n  comparison.primary = function(_) {\n    if (!arguments.length) return primary;\n    primary = _;\n    return comparison;\n  };\n\n  comparison.secondary = function(_) {\n    if (!arguments.length) return secondary;\n    secondary = _;\n    return comparison;\n  };\n\n  comparison.scale = function(_) {\n    if (!arguments.length) return scale;\n    scale = _;\n    return comparison;\n  };\n\n  comparison.extent = function(_) {\n    if (!arguments.length) return extent;\n    extent = _;\n    return comparison;\n  };\n\n  comparison.title = function(_) {\n    if (!arguments.length) return title;\n    title = _;\n    return comparison;\n  };\n\n  comparison.formatPrimary = function(_) {\n    if (!arguments.length) return formatPrimary;\n    formatPrimary = _;\n    return comparison;\n  };\n\n  comparison.formatChange = function(_) {\n    if (!arguments.length) return formatChange;\n    formatChange = _;\n    return comparison;\n  };\n\n  comparison.colors = function(_) {\n    if (!arguments.length) return colors;\n    colors = _;\n    return comparison;\n  };\n\n  comparison.strokeWidth = function(_) {\n    if (!arguments.length) return strokeWidth;\n    strokeWidth = _;\n    return comparison;\n  };\n\n  return comparison;\n};\n\nvar cubism_comparisonPrimaryFormat = d3.format(\".2s\"),\n    cubism_comparisonChangeFormat = d3.format(\"+.0%\");\n\nfunction cubism_comparisonRoundEven(i) {\n  return i & 0xfffffe;\n}\n\nfunction cubism_comparisonRoundOdd(i) {\n  return ((i + 1) & 0xfffffe) - 1;\n}\ncubism_contextPrototype.axis = function() {\n  var context = this,\n      scale = context.scale,\n      axis_ = d3.svg.axis().scale(scale);\n\n  var formatDefault = context.step() < 6e4 ? cubism_axisFormatSeconds\n      : context.step() < 864e5 ? cubism_axisFormatMinutes\n      : cubism_axisFormatDays;\n  var format = formatDefault;\n\n  function axis(selection) {\n    var id = ++cubism_id,\n        tick;\n\n    var g = selection.append(\"svg\")\n        .datum({id: id})\n        .attr(\"width\", context.size())\n        .attr(\"height\", Math.max(28, -axis.tickSize()))\n      .append(\"g\")\n        .attr(\"transform\", \"translate(0,\" + (axis_.orient() === \"top\" ? 27 : 4) + \")\")\n        .call(axis_);\n\n    context.on(\"change.axis-\" + id, function() {\n      g.call(axis_);\n      if (!tick) tick = d3.select(g.node().appendChild(g.selectAll(\"text\").node().cloneNode(true)))\n          .style(\"display\", \"none\")\n          .text(null);\n    });\n\n    context.on(\"focus.axis-\" + id, function(i) {\n      if (tick) {\n        if (i == null) {\n          tick.style(\"display\", \"none\");\n          g.selectAll(\"text\").style(\"fill-opacity\", null);\n        } else {\n          tick.style(\"display\", null).attr(\"x\", i).text(format(scale.invert(i)));\n          var dx = tick.node().getComputedTextLength() + 6;\n          g.selectAll(\"text\").style(\"fill-opacity\", function(d) { return Math.abs(scale(d) - i) < dx ? 0 : 1; });\n        }\n      }\n    });\n  }\n\n  axis.remove = function(selection) {\n\n    selection.selectAll(\"svg\")\n        .each(remove)\n        .remove();\n\n    function remove(d) {\n      context.on(\"change.axis-\" + d.id, null);\n      context.on(\"focus.axis-\" + d.id, null);\n    }\n  };\n\n  axis.focusFormat = function(_) {\n    if (!arguments.length) return format == formatDefault ? null : _;\n    format = _ == null ? formatDefault : _;\n    return axis;\n  };\n\n  return d3.rebind(axis, axis_,\n      \"orient\",\n      \"ticks\",\n      \"tickSubdivide\",\n      \"tickSize\",\n      \"tickPadding\",\n      \"tickFormat\");\n};\n\nvar cubism_axisFormatSeconds = d3.time.format(\"%I:%M:%S %p\"),\n    cubism_axisFormatMinutes = d3.time.format(\"%I:%M %p\"),\n    cubism_axisFormatDays = d3.time.format(\"%B %d\");\ncubism_contextPrototype.rule = function() {\n  var context = this,\n      metric = cubism_identity;\n\n  function rule(selection) {\n    var id = ++cubism_id;\n\n    var line = selection.append(\"div\")\n        .datum({id: id})\n        .attr(\"class\", \"line\")\n        .call(cubism_ruleStyle);\n\n    selection.each(function(d, i) {\n      var that = this,\n          id = ++cubism_id,\n          metric_ = typeof metric === \"function\" ? metric.call(that, d, i) : metric;\n\n      if (!metric_) return;\n\n      function change(start, stop) {\n        var values = [];\n\n        for (var i = 0, n = context.size(); i < n; ++i) {\n          if (metric_.valueAt(i)) {\n            values.push(i);\n          }\n        }\n\n        var lines = selection.selectAll(\".metric\").data(values);\n        lines.exit().remove();\n        lines.enter().append(\"div\").attr(\"class\", \"metric line\").call(cubism_ruleStyle);\n        lines.style(\"left\", cubism_ruleLeft);\n      }\n\n      context.on(\"change.rule-\" + id, change);\n      metric_.on(\"change.rule-\" + id, change);\n    });\n\n    context.on(\"focus.rule-\" + id, function(i) {\n      line.datum(i)\n          .style(\"display\", i == null ? \"none\" : null)\n          .style(\"left\", i == null ? null : cubism_ruleLeft);\n    });\n  }\n\n  rule.remove = function(selection) {\n\n    selection.selectAll(\".line\")\n        .each(remove)\n        .remove();\n\n    function remove(d) {\n      context.on(\"focus.rule-\" + d.id, null);\n    }\n  };\n\n  rule.metric = function(_) {\n    if (!arguments.length) return metric;\n    metric = _;\n    return rule;\n  };\n\n  return rule;\n};\n\nfunction cubism_ruleStyle(line) {\n  line\n      .style(\"position\", \"absolute\")\n      .style(\"top\", 0)\n      .style(\"bottom\", 0)\n      .style(\"width\", \"1px\")\n      .style(\"pointer-events\", \"none\");\n}\n\nfunction cubism_ruleLeft(i) {\n  return i + \"px\";\n}\n})(this);\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/axis.js":"cubism_contextPrototype.axis = function() {\n  var context = this,\n      scale = context.scale,\n      axis_ = d3.svg.axis().scale(scale);\n\n  var formatDefault = context.step() < 6e4 ? cubism_axisFormatSeconds\n      : context.step() < 864e5 ? cubism_axisFormatMinutes\n      : cubism_axisFormatDays;\n  var format = formatDefault;\n\n  function axis(selection) {\n    var id = ++cubism_id,\n        tick;\n\n    var g = selection.append(\"svg\")\n        .datum({id: id})\n        .attr(\"width\", context.size())\n        .attr(\"height\", Math.max(28, -axis.tickSize()))\n      .append(\"g\")\n        .attr(\"transform\", \"translate(0,\" + (axis_.orient() === \"top\" ? 27 : 4) + \")\")\n        .call(axis_);\n\n    context.on(\"change.axis-\" + id, function() {\n      g.call(axis_);\n      if (!tick) tick = d3.select(g.node().appendChild(g.selectAll(\"text\").node().cloneNode(true)))\n          .style(\"display\", \"none\")\n          .text(null);\n    });\n\n    context.on(\"focus.axis-\" + id, function(i) {\n      if (tick) {\n        if (i == null) {\n          tick.style(\"display\", \"none\");\n          g.selectAll(\"text\").style(\"fill-opacity\", null);\n        } else {\n          tick.style(\"display\", null).attr(\"x\", i).text(format(scale.invert(i)));\n          var dx = tick.node().getComputedTextLength() + 6;\n          g.selectAll(\"text\").style(\"fill-opacity\", function(d) { return Math.abs(scale(d) - i) < dx ? 0 : 1; });\n        }\n      }\n    });\n  }\n\n  axis.remove = function(selection) {\n\n    selection.selectAll(\"svg\")\n        .each(remove)\n        .remove();\n\n    function remove(d) {\n      context.on(\"change.axis-\" + d.id, null);\n      context.on(\"focus.axis-\" + d.id, null);\n    }\n  };\n\n  axis.focusFormat = function(_) {\n    if (!arguments.length) return format == formatDefault ? null : _;\n    format = _ == null ? formatDefault : _;\n    return axis;\n  };\n\n  return d3.rebind(axis, axis_,\n      \"orient\",\n      \"ticks\",\n      \"tickSubdivide\",\n      \"tickSize\",\n      \"tickPadding\",\n      \"tickFormat\");\n};\n\nvar cubism_axisFormatSeconds = d3.time.format(\"%I:%M:%S %p\"),\n    cubism_axisFormatMinutes = d3.time.format(\"%I:%M %p\"),\n    cubism_axisFormatDays = d3.time.format(\"%B %d\");\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/comparison.js":"cubism_contextPrototype.comparison = function() {\n  var context = this,\n      width = context.size(),\n      height = 120,\n      scale = d3.scale.linear().interpolate(d3.interpolateRound),\n      primary = function(d) { return d[0]; },\n      secondary = function(d) { return d[1]; },\n      extent = null,\n      title = cubism_identity,\n      formatPrimary = cubism_comparisonPrimaryFormat,\n      formatChange = cubism_comparisonChangeFormat,\n      colors = [\"#9ecae1\", \"#225b84\", \"#a1d99b\", \"#22723a\"],\n      strokeWidth = 1.5;\n\n  function comparison(selection) {\n\n    selection\n        .on(\"mousemove.comparison\", function() { context.focus(Math.round(d3.mouse(this)[0])); })\n        .on(\"mouseout.comparison\", function() { context.focus(null); });\n\n    selection.append(\"canvas\")\n        .attr(\"width\", width)\n        .attr(\"height\", height);\n\n    selection.append(\"span\")\n        .attr(\"class\", \"title\")\n        .text(title);\n\n    selection.append(\"span\")\n        .attr(\"class\", \"value primary\");\n\n    selection.append(\"span\")\n        .attr(\"class\", \"value change\");\n\n    selection.each(function(d, i) {\n      var that = this,\n          id = ++cubism_id,\n          primary_ = typeof primary === \"function\" ? primary.call(that, d, i) : primary,\n          secondary_ = typeof secondary === \"function\" ? secondary.call(that, d, i) : secondary,\n          extent_ = typeof extent === \"function\" ? extent.call(that, d, i) : extent,\n          div = d3.select(that),\n          canvas = div.select(\"canvas\"),\n          spanPrimary = div.select(\".value.primary\"),\n          spanChange = div.select(\".value.change\"),\n          ready;\n\n      canvas.datum({id: id, primary: primary_, secondary: secondary_});\n      canvas = canvas.node().getContext(\"2d\");\n\n      function change(start, stop) {\n        canvas.save();\n        canvas.clearRect(0, 0, width, height);\n\n        // update the scale\n        var primaryExtent = primary_.extent(),\n            secondaryExtent = secondary_.extent(),\n            extent = extent_ == null ? primaryExtent : extent_;\n        scale.domain(extent).range([height, 0]);\n        ready = primaryExtent.concat(secondaryExtent).every(isFinite);\n\n        // consistent overplotting\n        var round = start / context.step() & 1\n            ? cubism_comparisonRoundOdd\n            : cubism_comparisonRoundEven;\n\n        // positive changes\n        canvas.fillStyle = colors[2];\n        for (var i = 0, n = width; i < n; ++i) {\n          var y0 = scale(primary_.valueAt(i)),\n              y1 = scale(secondary_.valueAt(i));\n          if (y0 < y1) canvas.fillRect(round(i), y0, 1, y1 - y0);\n        }\n\n        // negative changes\n        canvas.fillStyle = colors[0];\n        for (i = 0; i < n; ++i) {\n          var y0 = scale(primary_.valueAt(i)),\n              y1 = scale(secondary_.valueAt(i));\n          if (y0 > y1) canvas.fillRect(round(i), y1, 1, y0 - y1);\n        }\n\n        // positive values\n        canvas.fillStyle = colors[3];\n        for (i = 0; i < n; ++i) {\n          var y0 = scale(primary_.valueAt(i)),\n              y1 = scale(secondary_.valueAt(i));\n          if (y0 <= y1) canvas.fillRect(round(i), y0, 1, strokeWidth);\n        }\n\n        // negative values\n        canvas.fillStyle = colors[1];\n        for (i = 0; i < n; ++i) {\n          var y0 = scale(primary_.valueAt(i)),\n              y1 = scale(secondary_.valueAt(i));\n          if (y0 > y1) canvas.fillRect(round(i), y0 - strokeWidth, 1, strokeWidth);\n        }\n\n        canvas.restore();\n      }\n\n      function focus(i) {\n        if (i == null) i = width - 1;\n        var valuePrimary = primary_.valueAt(i),\n            valueSecondary = secondary_.valueAt(i),\n            valueChange = (valuePrimary - valueSecondary) / valueSecondary;\n\n        spanPrimary\n            .datum(valuePrimary)\n            .text(isNaN(valuePrimary) ? null : formatPrimary);\n\n        spanChange\n            .datum(valueChange)\n            .text(isNaN(valueChange) ? null : formatChange)\n            .attr(\"class\", \"value change \" + (valueChange > 0 ? \"positive\" : valueChange < 0 ? \"negative\" : \"\"));\n      }\n\n      // Display the first primary change immediately,\n      // but defer subsequent updates to the context change.\n      // Note that someone still needs to listen to the metric,\n      // so that it continues to update automatically.\n      primary_.on(\"change.comparison-\" + id, firstChange);\n      secondary_.on(\"change.comparison-\" + id, firstChange);\n      function firstChange(start, stop) {\n        change(start, stop), focus();\n        if (ready) {\n          primary_.on(\"change.comparison-\" + id, cubism_identity);\n          secondary_.on(\"change.comparison-\" + id, cubism_identity);\n        }\n      }\n\n      // Update the chart when the context changes.\n      context.on(\"change.comparison-\" + id, change);\n      context.on(\"focus.comparison-\" + id, focus);\n    });\n  }\n\n  comparison.remove = function(selection) {\n\n    selection\n        .on(\"mousemove.comparison\", null)\n        .on(\"mouseout.comparison\", null);\n\n    selection.selectAll(\"canvas\")\n        .each(remove)\n        .remove();\n\n    selection.selectAll(\".title,.value\")\n        .remove();\n\n    function remove(d) {\n      d.primary.on(\"change.comparison-\" + d.id, null);\n      d.secondary.on(\"change.comparison-\" + d.id, null);\n      context.on(\"change.comparison-\" + d.id, null);\n      context.on(\"focus.comparison-\" + d.id, null);\n    }\n  };\n\n  comparison.height = function(_) {\n    if (!arguments.length) return height;\n    height = +_;\n    return comparison;\n  };\n\n  comparison.primary = function(_) {\n    if (!arguments.length) return primary;\n    primary = _;\n    return comparison;\n  };\n\n  comparison.secondary = function(_) {\n    if (!arguments.length) return secondary;\n    secondary = _;\n    return comparison;\n  };\n\n  comparison.scale = function(_) {\n    if (!arguments.length) return scale;\n    scale = _;\n    return comparison;\n  };\n\n  comparison.extent = function(_) {\n    if (!arguments.length) return extent;\n    extent = _;\n    return comparison;\n  };\n\n  comparison.title = function(_) {\n    if (!arguments.length) return title;\n    title = _;\n    return comparison;\n  };\n\n  comparison.formatPrimary = function(_) {\n    if (!arguments.length) return formatPrimary;\n    formatPrimary = _;\n    return comparison;\n  };\n\n  comparison.formatChange = function(_) {\n    if (!arguments.length) return formatChange;\n    formatChange = _;\n    return comparison;\n  };\n\n  comparison.colors = function(_) {\n    if (!arguments.length) return colors;\n    colors = _;\n    return comparison;\n  };\n\n  comparison.strokeWidth = function(_) {\n    if (!arguments.length) return strokeWidth;\n    strokeWidth = _;\n    return comparison;\n  };\n\n  return comparison;\n};\n\nvar cubism_comparisonPrimaryFormat = d3.format(\".2s\"),\n    cubism_comparisonChangeFormat = d3.format(\"+.0%\");\n\nfunction cubism_comparisonRoundEven(i) {\n  return i & 0xfffffe;\n}\n\nfunction cubism_comparisonRoundOdd(i) {\n  return ((i + 1) & 0xfffffe) - 1;\n}\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/context.js":"cubism.context = function() {\n  var context = new cubism_context,\n      step = 1e4, // ten seconds, in milliseconds\n      size = 1440, // four hours at ten seconds, in pixels\n      start0, stop0, // the start and stop for the previous change event\n      start1, stop1, // the start and stop for the next prepare event\n      serverDelay = 5e3,\n      clientDelay = 5e3,\n      event = d3.dispatch(\"prepare\", \"beforechange\", \"change\", \"focus\"),\n      scale = context.scale = d3.time.scale().range([0, size]),\n      timeout,\n      focus;\n\n  function update() {\n    var now = Date.now();\n    stop0 = new Date(Math.floor((now - serverDelay - clientDelay) / step) * step);\n    start0 = new Date(stop0 - size * step);\n    stop1 = new Date(Math.floor((now - serverDelay) / step) * step);\n    start1 = new Date(stop1 - size * step);\n    scale.domain([start0, stop0]);\n    return context;\n  }\n\n  context.start = function() {\n    if (timeout) clearTimeout(timeout);\n    var delay = +stop1 + serverDelay - Date.now();\n\n    // If we're too late for the first prepare event, skip it.\n    if (delay < clientDelay) delay += step;\n\n    timeout = setTimeout(function prepare() {\n      stop1 = new Date(Math.floor((Date.now() - serverDelay) / step) * step);\n      start1 = new Date(stop1 - size * step);\n      event.prepare.call(context, start1, stop1);\n\n      setTimeout(function() {\n        scale.domain([start0 = start1, stop0 = stop1]);\n        event.beforechange.call(context, start1, stop1);\n        event.change.call(context, start1, stop1);\n        event.focus.call(context, focus);\n      }, clientDelay);\n\n      timeout = setTimeout(prepare, step);\n    }, delay);\n    return context;\n  };\n\n  context.stop = function() {\n    timeout = clearTimeout(timeout);\n    return context;\n  };\n\n  timeout = setTimeout(context.start, 10);\n\n  // Set or get the step interval in milliseconds.\n  // Defaults to ten seconds.\n  context.step = function(_) {\n    if (!arguments.length) return step;\n    step = +_;\n    return update();\n  };\n\n  // Set or get the context size (the count of metric values).\n  // Defaults to 1440 (four hours at ten seconds).\n  context.size = function(_) {\n    if (!arguments.length) return size;\n    scale.range([0, size = +_]);\n    return update();\n  };\n\n  // The server delay is the amount of time we wait for the server to compute a\n  // metric. This delay may result from clock skew or from delays collecting\n  // metrics from various hosts. Defaults to 4 seconds.\n  context.serverDelay = function(_) {\n    if (!arguments.length) return serverDelay;\n    serverDelay = +_;\n    return update();\n  };\n\n  // The client delay is the amount of additional time we wait to fetch those\n  // metrics from the server. The client and server delay combined represent the\n  // age of the most recent displayed metric. Defaults to 1 second.\n  context.clientDelay = function(_) {\n    if (!arguments.length) return clientDelay;\n    clientDelay = +_;\n    return update();\n  };\n\n  // Sets the focus to the specified index, and dispatches a \"focus\" event.\n  context.focus = function(i) {\n    event.focus.call(context, focus = i);\n    return context;\n  };\n\n  // Add, remove or get listeners for events.\n  context.on = function(type, listener) {\n    if (arguments.length < 2) return event.on(type);\n\n    event.on(type, listener);\n\n    // Notify the listener of the current start and stop time, as appropriate.\n    // This way, metrics can make requests for data immediately,\n    // and likewise the axis can display itself synchronously.\n    if (listener != null) {\n      if (/^prepare(\\.|$)/.test(type)) listener.call(context, start1, stop1);\n      if (/^beforechange(\\.|$)/.test(type)) listener.call(context, start0, stop0);\n      if (/^change(\\.|$)/.test(type)) listener.call(context, start0, stop0);\n      if (/^focus(\\.|$)/.test(type)) listener.call(context, focus);\n    }\n\n    return context;\n  };\n\n  d3.select(window).on(\"keydown.context-\" + ++cubism_id, function() {\n    switch (!d3.event.metaKey && d3.event.keyCode) {\n      case 37: // left\n        if (focus == null) focus = size - 1;\n        if (focus > 0) context.focus(--focus);\n        break;\n      case 39: // right\n        if (focus == null) focus = size - 2;\n        if (focus < size - 1) context.focus(++focus);\n        break;\n      default: return;\n    }\n    d3.event.preventDefault();\n  });\n\n  return update();\n};\n\nfunction cubism_context() {}\n\nvar cubism_contextPrototype = cubism.context.prototype = cubism_context.prototype;\n\ncubism_contextPrototype.constant = function(value) {\n  return new cubism_metricConstant(this, +value);\n};\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/cube.js":"cubism_contextPrototype.cube = function(host) {\n  if (!arguments.length) host = \"\";\n  var source = {},\n      context = this;\n\n  source.metric = function(expression) {\n    return context.metric(function(start, stop, step, callback) {\n      d3.json(host + \"/1.0/metric\"\n          + \"?expression=\" + encodeURIComponent(expression)\n          + \"&start=\" + cubism_cubeFormatDate(start)\n          + \"&stop=\" + cubism_cubeFormatDate(stop)\n          + \"&step=\" + step, function(data) {\n        if (!data) return callback(new Error(\"unable to load data\"));\n        callback(null, data.map(function(d) { return d.value; }));\n      });\n    }, expression += \"\");\n  };\n\n  // Returns the Cube host.\n  source.toString = function() {\n    return host;\n  };\n\n  return source;\n};\n\nvar cubism_cubeFormatDate = d3.time.format.iso;\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/cubism.js":"var cubism = exports.cubism = {version: \"1.6.0\"};\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/gangliaWeb.js":"cubism_contextPrototype.gangliaWeb = function(config) {\n  var host = '',\n      uriPathPrefix = '/ganglia2/';\n \n  if (arguments.length) {\n    if (config.host) {\n      host = config.host;\n    }\n\n    if (config.uriPathPrefix) {\n      uriPathPrefix = config.uriPathPrefix;\n\n      /* Add leading and trailing slashes, as appropriate. */\n      if( uriPathPrefix[0] != '/' ) {\n        uriPathPrefix = '/' + uriPathPrefix;\n      }\n\n      if( uriPathPrefix[uriPathPrefix.length - 1] != '/' ) {\n        uriPathPrefix += '/';\n      }\n    }\n  }\n\n  var source = {},\n      context = this;\n\n  source.metric = function(metricInfo) {\n\n    /* Store the members from metricInfo into local variables. */\n    var clusterName = metricInfo.clusterName, \n        metricName = metricInfo.metricName, \n        hostName = metricInfo.hostName,\n        isReport = metricInfo.isReport || false,\n        titleGenerator = metricInfo.titleGenerator ||\n          /* Reasonable (not necessarily pretty) default for titleGenerator. */\n          function(unusedMetricInfo) {\n            /* unusedMetricInfo is, well, unused in this default case. */\n            return ('clusterName:' + clusterName + \n                    ' metricName:' + metricName +\n                    (hostName ? ' hostName:' + hostName : ''));\n          },\n        onChangeCallback = metricInfo.onChangeCallback;\n    \n    /* Default to plain, simple metrics. */\n    var metricKeyName = isReport ? 'g' : 'm';\n\n    var gangliaWebMetric = context.metric(function(start, stop, step, callback) {\n\n      function constructGangliaWebRequestQueryParams() {\n        return ('c=' + clusterName +\n                '&' + metricKeyName + '=' + metricName + \n                (hostName ? '&h=' + hostName : '') + \n                '&cs=' + start/1000 + '&ce=' + stop/1000 + '&step=' + step/1000 + '&graphlot=1');\n      }\n\n      d3.json(host + uriPathPrefix + 'graph.php?' + constructGangliaWebRequestQueryParams(),\n        function(result) {\n          if( !result ) {\n            return callback(new Error(\"Unable to fetch GangliaWeb data\"));\n          }\n\n          callback(null, result[0].data);\n        });\n\n    }, titleGenerator(metricInfo));\n\n    gangliaWebMetric.toString = function() {\n      return titleGenerator(metricInfo);\n    };\n\n    /* Allow users to run their custom code each time a gangliaWebMetric changes.\n     *\n     * TODO Consider abstracting away the naked Cubism call, and instead exposing \n     * a callback that takes in the values array (maybe alongwith the original\n     * start and stop 'naked' parameters), since it's handy to have the entire\n     * dataset at your disposal (and users will likely implement onChangeCallback\n     * primarily to get at this dataset).\n     */\n    if (onChangeCallback) {\n      gangliaWebMetric.on('change', onChangeCallback);\n    }\n\n    return gangliaWebMetric;\n  };\n\n  // Returns the gangliaWeb host + uriPathPrefix.\n  source.toString = function() {\n    return host + uriPathPrefix;\n  };\n\n  return source;\n};\n\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/graphite.js":"cubism_contextPrototype.graphite = function(host) {\n  if (!arguments.length) host = \"\";\n  var source = {},\n      context = this;\n\n  source.metric = function(expression) {\n    var sum = \"sum\";\n\n    var metric = context.metric(function(start, stop, step, callback) {\n      var target = expression;\n\n      // Apply the summarize, if necessary.\n      if (step !== 1e4) target = \"summarize(\" + target + \",'\"\n          + (!(step % 36e5) ? step / 36e5 + \"hour\" : !(step % 6e4) ? step / 6e4 + \"min\" : step / 1e3 + \"sec\")\n          + \"','\" + sum + \"')\";\n\n      d3.text(host + \"/render?format=raw\"\n          + \"&target=\" + encodeURIComponent(\"alias(\" + target + \",'')\")\n          + \"&from=\" + cubism_graphiteFormatDate(start - 2 * step) // off-by-two?\n          + \"&until=\" + cubism_graphiteFormatDate(stop - 1000), function(text) {\n        if (!text) return callback(new Error(\"unable to load data\"));\n        callback(null, cubism_graphiteParse(text));\n      });\n    }, expression += \"\");\n\n    metric.summarize = function(_) {\n      sum = _;\n      return metric;\n    };\n\n    return metric;\n  };\n\n  source.find = function(pattern, callback) {\n    d3.json(host + \"/metrics/find?format=completer\"\n        + \"&query=\" + encodeURIComponent(pattern), function(result) {\n      if (!result) return callback(new Error(\"unable to find metrics\"));\n      callback(null, result.metrics.map(function(d) { return d.path; }));\n    });\n  };\n\n  // Returns the graphite host.\n  source.toString = function() {\n    return host;\n  };\n\n  return source;\n};\n\n// Graphite understands seconds since UNIX epoch.\nfunction cubism_graphiteFormatDate(time) {\n  return Math.floor(time / 1000);\n}\n\n// Helper method for parsing graphite's raw format.\nfunction cubism_graphiteParse(text) {\n  var i = text.indexOf(\"|\"),\n      meta = text.substring(0, i),\n      c = meta.lastIndexOf(\",\"),\n      b = meta.lastIndexOf(\",\", c - 1),\n      a = meta.lastIndexOf(\",\", b - 1),\n      start = meta.substring(a + 1, b) * 1000,\n      step = meta.substring(c + 1) * 1000;\n  return text\n      .substring(i + 1)\n      .split(\",\")\n      .slice(1) // the first value is always None?\n      .map(function(d) { return +d; });\n}\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/horizon.js":"cubism_contextPrototype.horizon = function() {\n  var context = this,\n      mode = \"offset\",\n      buffer = document.createElement(\"canvas\"),\n      width = buffer.width = context.size(),\n      height = buffer.height = 30,\n      scale = d3.scale.linear().interpolate(d3.interpolateRound),\n      metric = cubism_identity,\n      extent = null,\n      title = cubism_identity,\n      format = d3.format(\".2s\"),\n      colors = [\"#08519c\",\"#3182bd\",\"#6baed6\",\"#bdd7e7\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"];\n\n  function horizon(selection) {\n\n    selection\n        .on(\"mousemove.horizon\", function() { context.focus(Math.round(d3.mouse(this)[0])); })\n        .on(\"mouseout.horizon\", function() { context.focus(null); });\n\n    selection.append(\"canvas\")\n        .attr(\"width\", width)\n        .attr(\"height\", height);\n\n    selection.append(\"span\")\n        .attr(\"class\", \"title\")\n        .text(title);\n\n    selection.append(\"span\")\n        .attr(\"class\", \"value\");\n\n    selection.each(function(d, i) {\n      var that = this,\n          id = ++cubism_id,\n          metric_ = typeof metric === \"function\" ? metric.call(that, d, i) : metric,\n          colors_ = typeof colors === \"function\" ? colors.call(that, d, i) : colors,\n          extent_ = typeof extent === \"function\" ? extent.call(that, d, i) : extent,\n          start = -Infinity,\n          step = context.step(),\n          canvas = d3.select(that).select(\"canvas\"),\n          span = d3.select(that).select(\".value\"),\n          max_,\n          m = colors_.length >> 1,\n          ready;\n\n      canvas.datum({id: id, metric: metric_});\n      canvas = canvas.node().getContext(\"2d\");\n\n      function change(start1, stop) {\n        canvas.save();\n\n        // compute the new extent and ready flag\n        var extent = metric_.extent();\n        ready = extent.every(isFinite);\n        if (extent_ != null) extent = extent_;\n\n        // if this is an update (with no extent change), copy old values!\n        var i0 = 0, max = Math.max(-extent[0], extent[1]);\n        if (this === context) {\n          if (max == max_) {\n            i0 = width - cubism_metricOverlap;\n            var dx = (start1 - start) / step;\n            if (dx < width) {\n              var canvas0 = buffer.getContext(\"2d\");\n              canvas0.clearRect(0, 0, width, height);\n              canvas0.drawImage(canvas.canvas, dx, 0, width - dx, height, 0, 0, width - dx, height);\n              canvas.clearRect(0, 0, width, height);\n              canvas.drawImage(canvas0.canvas, 0, 0);\n            }\n          }\n          start = start1;\n        }\n\n        // update the domain\n        scale.domain([0, max_ = max]);\n\n        // clear for the new data\n        canvas.clearRect(i0, 0, width - i0, height);\n\n        // record whether there are negative values to display\n        var negative;\n\n        // positive bands\n        for (var j = 0; j < m; ++j) {\n          canvas.fillStyle = colors_[m + j];\n\n          // Adjust the range based on the current band index.\n          var y0 = (j - m + 1) * height;\n          scale.range([m * height + y0, y0]);\n          y0 = scale(0);\n\n          for (var i = i0, n = width, y1; i < n; ++i) {\n            y1 = metric_.valueAt(i);\n            if (y1 <= 0) { negative = true; continue; }\n            if (y1 === undefined) continue;\n            canvas.fillRect(i, y1 = scale(y1), 1, y0 - y1);\n          }\n        }\n\n        if (negative) {\n          // enable offset mode\n          if (mode === \"offset\") {\n            canvas.translate(0, height);\n            canvas.scale(1, -1);\n          }\n\n          // negative bands\n          for (var j = 0; j < m; ++j) {\n            canvas.fillStyle = colors_[m - 1 - j];\n\n            // Adjust the range based on the current band index.\n            var y0 = (j - m + 1) * height;\n            scale.range([m * height + y0, y0]);\n            y0 = scale(0);\n\n            for (var i = i0, n = width, y1; i < n; ++i) {\n              y1 = metric_.valueAt(i);\n              if (y1 >= 0) continue;\n              canvas.fillRect(i, scale(-y1), 1, y0 - scale(-y1));\n            }\n          }\n        }\n\n        canvas.restore();\n      }\n\n      function focus(i) {\n        if (i == null) i = width - 1;\n        var value = metric_.valueAt(i);\n        span.datum(value).text(isNaN(value) ? null : format);\n      }\n\n      // Update the chart when the context changes.\n      context.on(\"change.horizon-\" + id, change);\n      context.on(\"focus.horizon-\" + id, focus);\n\n      // Display the first metric change immediately,\n      // but defer subsequent updates to the canvas change.\n      // Note that someone still needs to listen to the metric,\n      // so that it continues to update automatically.\n      metric_.on(\"change.horizon-\" + id, function(start, stop) {\n        change(start, stop), focus();\n        if (ready) metric_.on(\"change.horizon-\" + id, cubism_identity);\n      });\n    });\n  }\n\n  horizon.remove = function(selection) {\n\n    selection\n        .on(\"mousemove.horizon\", null)\n        .on(\"mouseout.horizon\", null);\n\n    selection.selectAll(\"canvas\")\n        .each(remove)\n        .remove();\n\n    selection.selectAll(\".title,.value\")\n        .remove();\n\n    function remove(d) {\n      d.metric.on(\"change.horizon-\" + d.id, null);\n      context.on(\"change.horizon-\" + d.id, null);\n      context.on(\"focus.horizon-\" + d.id, null);\n    }\n  };\n\n  horizon.mode = function(_) {\n    if (!arguments.length) return mode;\n    mode = _ + \"\";\n    return horizon;\n  };\n\n  horizon.height = function(_) {\n    if (!arguments.length) return height;\n    buffer.height = height = +_;\n    return horizon;\n  };\n\n  horizon.metric = function(_) {\n    if (!arguments.length) return metric;\n    metric = _;\n    return horizon;\n  };\n\n  horizon.scale = function(_) {\n    if (!arguments.length) return scale;\n    scale = _;\n    return horizon;\n  };\n\n  horizon.extent = function(_) {\n    if (!arguments.length) return extent;\n    extent = _;\n    return horizon;\n  };\n\n  horizon.title = function(_) {\n    if (!arguments.length) return title;\n    title = _;\n    return horizon;\n  };\n\n  horizon.format = function(_) {\n    if (!arguments.length) return format;\n    format = _;\n    return horizon;\n  };\n\n  horizon.colors = function(_) {\n    if (!arguments.length) return colors;\n    colors = _;\n    return horizon;\n  };\n\n  return horizon;\n};\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/identity.js":"function cubism_identity(d) { return d; }\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/id.js":"var cubism_id = 0;\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/librato.js":"/* librato (http://dev.librato.com/v1/post/metrics) source\n * If you want to see an example of how to use this source, check: https://gist.github.com/drio/5792680\n */\ncubism_contextPrototype.librato = function(user, token) {\n  var source      = {},\n      context     = this;\n      auth_string = \"Basic \" + btoa(user + \":\" + token);\n      avail_rsts  = [ 1, 60, 900, 3600 ];\n\n  /* Given a step, find the best librato resolution to use.\n   *\n   * Example:\n   *\n   * (s) : cubism step\n   *\n   * avail_rsts   1 --------------- 60 --------------- 900 ---------------- 3600\n   *                                |    (s)            |\n   *                                |                   |\n   *                              [low_res             top_res]\n   *\n   * return: low_res (60)\n   */\n  function find_ideal_librato_resolution(step) {\n    var highest_res = avail_rsts[0],\n        lowest_res  = avail_rsts[avail_rsts.length]; // high and lowest available resolution from librato\n\n    /* If step is outside the highest or lowest librato resolution, pick them and we are done */\n    if (step >= lowest_res)\n      return lowest_res;\n\n    if (step <= highest_res)\n      return highest_res;\n\n    /* If not, find in what resolution interval the step lands. */\n    var iof, top_res, i;\n    for (i=step; i<=lowest_res; i++) {\n      iof = avail_rsts.indexOf(i);\n      if (iof > -1) {\n        top_res = avail_rsts[iof];\n        break;\n      }\n    }\n\n    var low_res;\n    for (i=step; i>=highest_res; i--) {\n      iof = avail_rsts.indexOf(i);\n      if (iof > -1) {\n        low_res = avail_rsts[iof];\n        break;\n      }\n    }\n\n    /* What's the closest librato resolution given the step ? */\n    return ((top_res-step) < (step-low_res)) ? top_res : low_res;\n  }\n\n  function find_librato_resolution(sdate, edate, step) {\n    var i_size      = edate - sdate,                 // interval size\n        month       = 2419200,\n        week        = 604800,\n        two_days    = 172800,\n        ideal_res;\n\n    if (i_size > month)\n      return 3600;\n\n    ideal_res = find_ideal_librato_resolution(step);\n\n    /*\n     * Now we have the ideal resolution, but due to the retention policies at librato, maybe we have\n     * to use a higher resolution.\n     * http://support.metrics.librato.com/knowledgebase/articles/66838-understanding-metrics-roll-ups-retention-and-grap\n     */\n    if (i_size > week && ideal_res < 900)\n      return 900;\n    else if (i_size > two_days && ideal_res < 60)\n      return 60;\n    else\n      return ideal_res;\n  }\n\n  /* All the logic to query the librato API is here */\n  var librato_request = function(composite) {\n    var url_prefix  = \"https://metrics-api.librato.com/v1/metrics\";\n\n    function make_url(sdate, edate, step) {\n      var params    = \"compose=\"     + composite +\n                      \"&start_time=\" + sdate     +\n                      \"&end_time=\"   + edate     +\n                      \"&resolution=\" + find_librato_resolution(sdate, edate, step);\n      return url_prefix + \"?\" + params;\n    }\n\n    /*\n     * We are most likely not going to get the same number of measurements\n     * cubism expects for a particular context: We have to perform down/up\n     * sampling\n     */\n    function down_up_sampling(isdate, iedate, step, librato_mm) {\n      var av = [];\n\n      for (i=isdate; i<=iedate; i+=step) {\n        var int_mes = [];\n        while (librato_mm.length && librato_mm[0].measure_time <= i) {\n          int_mes.push(librato_mm.shift().value);\n        }\n\n        var v;\n        if (int_mes.length) { /* Compute the average */\n          v = int_mes.reduce(function(a, b) { return a + b }) / int_mes.length;\n        } else { /* No librato values on interval */\n          v = (av.length) ? av[av.length-1] : 0;\n        }\n        av.push(v);\n      }\n\n      return av;\n    }\n\n    request = {};\n\n    request.fire = function(isdate, iedate, step, callback_done) {\n      var a_values = []; /* Store partial values from librato */\n\n      /*\n       * Librato has a limit in the number of measurements we get back in a request (100).\n       * We recursively perform requests to the API to ensure we have all the data points\n       * for the interval we are working on.\n       */\n      function actual_request(full_url) {\n        d3.json(full_url)\n          .header(\"X-Requested-With\", \"XMLHttpRequest\")\n          .header(\"Authorization\", auth_string)\n          .header(\"Librato-User-Agent\", 'cubism/' + cubism.version)\n          .get(function (error, data) { /* Callback; data available */\n            if (!error) {\n              if (data.measurements.length === 0) {\n                return\n              }\n              data.measurements[0].series.forEach(function(o) { a_values.push(o); });\n\n              var still_more_values = 'query' in data && 'next_time' in data.query;\n              if (still_more_values) {\n                actual_request(make_url(data.query.next_time, iedate, step));\n              } else {\n                var a_adjusted = down_up_sampling(isdate, iedate, step, a_values);\n                callback_done(a_adjusted);\n              }\n            }\n          });\n      }\n\n      actual_request(make_url(isdate, iedate, step));\n    };\n\n    return request;\n  };\n\n  /*\n   * The user will use this method to create a cubism source (librato in this case)\n   * and call .metric() as necessary to create metrics.\n   */\n  source.metric = function(m_composite) {\n    return context.metric(function(start, stop, step, callback) {\n      /* All the librato logic is here; .fire() retrieves the metrics' data */\n      librato_request(m_composite)\n        .fire(cubism_libratoFormatDate(start),\n              cubism_libratoFormatDate(stop),\n              cubism_libratoFormatDate(step),\n              function(a_values) { callback(null, a_values); });\n\n      }, m_composite += \"\");\n    };\n\n  /* This is not used when the source is librato */\n  source.toString = function() {\n    return \"librato\";\n  };\n\n  return source;\n};\n\nvar cubism_libratoFormatDate = function(time) {\n  return Math.floor(time / 1000);\n};\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/metric-constant.js":"function cubism_metricConstant(context, value) {\n  cubism_metric.call(this, context);\n  value = +value;\n  var name = value + \"\";\n  this.valueOf = function() { return value; };\n  this.toString = function() { return name; };\n}\n\nvar cubism_metricConstantPrototype = cubism_metricConstant.prototype = Object.create(cubism_metric.prototype);\n\ncubism_metricConstantPrototype.valueAt = function() {\n  return +this;\n};\n\ncubism_metricConstantPrototype.extent = function() {\n  return [+this, +this];\n};\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/metric.js":"function cubism_metric(context) {\n  if (!(context instanceof cubism_context)) throw new Error(\"invalid context\");\n  this.context = context;\n}\n\nvar cubism_metricPrototype = cubism_metric.prototype;\n\ncubism.metric = cubism_metric;\n\ncubism_metricPrototype.valueAt = function() {\n  return NaN;\n};\n\ncubism_metricPrototype.alias = function(name) {\n  this.toString = function() { return name; };\n  return this;\n};\n\ncubism_metricPrototype.extent = function() {\n  var i = 0,\n      n = this.context.size(),\n      value,\n      min = Infinity,\n      max = -Infinity;\n  while (++i < n) {\n    value = this.valueAt(i);\n    if (value < min) min = value;\n    if (value > max) max = value;\n  }\n  return [min, max];\n};\n\ncubism_metricPrototype.on = function(type, listener) {\n  return arguments.length < 2 ? null : this;\n};\n\ncubism_metricPrototype.shift = function() {\n  return this;\n};\n\ncubism_metricPrototype.on = function() {\n  return arguments.length < 2 ? null : this;\n};\n\ncubism_contextPrototype.metric = function(request, name) {\n  var context = this,\n      metric = new cubism_metric(context),\n      id = \".metric-\" + ++cubism_id,\n      start = -Infinity,\n      stop,\n      step = context.step(),\n      size = context.size(),\n      values = [],\n      event = d3.dispatch(\"change\"),\n      listening = 0,\n      fetching;\n\n  // Prefetch new data into a temporary array.\n  function prepare(start1, stop) {\n    var steps = Math.min(size, Math.round((start1 - start) / step));\n    if (!steps || fetching) return; // already fetched, or fetching!\n    fetching = true;\n    steps = Math.min(size, steps + cubism_metricOverlap);\n    var start0 = new Date(stop - steps * step);\n    request(start0, stop, step, function(error, data) {\n      fetching = false;\n      if (error) return console.warn(error);\n      var i = isFinite(start) ? Math.round((start0 - start) / step) : 0;\n      for (var j = 0, m = data.length; j < m; ++j) values[j + i] = data[j];\n      event.change.call(metric, start, stop);\n    });\n  }\n\n  // When the context changes, switch to the new data, ready-or-not!\n  function beforechange(start1, stop1) {\n    if (!isFinite(start)) start = start1;\n    values.splice(0, Math.max(0, Math.min(size, Math.round((start1 - start) / step))));\n    start = start1;\n    stop = stop1;\n  }\n\n  //\n  metric.valueAt = function(i) {\n    return values[i];\n  };\n\n  //\n  metric.shift = function(offset) {\n    return context.metric(cubism_metricShift(request, +offset));\n  };\n\n  //\n  metric.on = function(type, listener) {\n    if (!arguments.length) return event.on(type);\n\n    // If there are no listeners, then stop listening to the context,\n    // and avoid unnecessary fetches.\n    if (listener == null) {\n      if (event.on(type) != null && --listening == 0) {\n        context.on(\"prepare\" + id, null).on(\"beforechange\" + id, null);\n      }\n    } else {\n      if (event.on(type) == null && ++listening == 1) {\n        context.on(\"prepare\" + id, prepare).on(\"beforechange\" + id, beforechange);\n      }\n    }\n\n    event.on(type, listener);\n\n    // Notify the listener of the current start and stop time, as appropriate.\n    // This way, charts can display synchronous metrics immediately.\n    if (listener != null) {\n      if (/^change(\\.|$)/.test(type)) listener.call(context, start, stop);\n    }\n\n    return metric;\n  };\n\n  //\n  if (arguments.length > 1) metric.toString = function() {\n    return name;\n  };\n\n  return metric;\n};\n\n// Number of metric to refetch each period, in case of lag.\nvar cubism_metricOverlap = 6;\n\n// Wraps the specified request implementation, and shifts time by the given offset.\nfunction cubism_metricShift(request, offset) {\n  return function(start, stop, step, callback) {\n    request(new Date(+start + offset), new Date(+stop + offset), step, callback);\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/metric-operator.js":"function cubism_metricOperator(name, operate) {\n\n  function cubism_metricOperator(left, right) {\n    if (!(right instanceof cubism_metric)) right = new cubism_metricConstant(left.context, right);\n    else if (left.context !== right.context) throw new Error(\"mismatch context\");\n    cubism_metric.call(this, left.context);\n    this.left = left;\n    this.right = right;\n    this.toString = function() { return left + \" \" + name + \" \" + right; };\n  }\n\n  var cubism_metricOperatorPrototype = cubism_metricOperator.prototype = Object.create(cubism_metric.prototype);\n\n  cubism_metricOperatorPrototype.valueAt = function(i) {\n    return operate(this.left.valueAt(i), this.right.valueAt(i));\n  };\n\n  cubism_metricOperatorPrototype.shift = function(offset) {\n    return new cubism_metricOperator(this.left.shift(offset), this.right.shift(offset));\n  };\n\n  cubism_metricOperatorPrototype.on = function(type, listener) {\n    if (arguments.length < 2) return this.left.on(type);\n    this.left.on(type, listener);\n    this.right.on(type, listener);\n    return this;\n  };\n\n  return function(right) {\n    return new cubism_metricOperator(this, right);\n  };\n}\n\ncubism_metricPrototype.add = cubism_metricOperator(\"+\", function(left, right) {\n  return left + right;\n});\n\ncubism_metricPrototype.subtract = cubism_metricOperator(\"-\", function(left, right) {\n  return left - right;\n});\n\ncubism_metricPrototype.multiply = cubism_metricOperator(\"*\", function(left, right) {\n  return left * right;\n});\n\ncubism_metricPrototype.divide = cubism_metricOperator(\"/\", function(left, right) {\n  return left / right;\n});\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/option.js":"cubism.option = function(name, defaultValue) {\n  var values = cubism.options(name);\n  return values.length ? values[0] : defaultValue;\n};\n\ncubism.options = function(name, defaultValues) {\n  var options = location.search.substring(1).split(\"&\"),\n      values = [],\n      i = -1,\n      n = options.length,\n      o;\n  while (++i < n) {\n    if ((o = options[i].split(\"=\"))[0] == name) {\n      values.push(decodeURIComponent(o[1]));\n    }\n  }\n  return values.length || arguments.length < 2 ? values : defaultValues;\n};\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/package.js":"var util = require(\"util\");\n\nnavigator = {} \n\nvar d3 = require(\"d3\"),\n    cubism = require(\"../cubism.v1\").cubism;\n\nutil.puts(JSON.stringify({\n  \"name\": \"cubism\",\n  \"version\": cubism.version,\n  \"description\": \"A JavaScript library for time series visualization.\",\n  \"keywords\": [\"time series\", \"visualization\", \"d3\"],\n  \"homepage\": \"http://square.github.com/cubism/\",\n  \"author\": {\"name\": \"Mike Bostock\", \"url\": \"http://bost.ocks.org/mike\"},\n  \"repository\": {\"type\": \"git\", \"url\": \"http://github.com/square/cubism.git\"},\n  \"main\": \"./index.js\",\n  \"dependencies\": {\n    \"d3\": \"3.x\"\n  },\n  \"devDependencies\": {\n    \"vows\": \"0.6.1\",\n    \"uglify-js\": \"1.2.5\"\n  }\n}\n, null, 2));\n","/home/travis/build/npmtest/node-npmtest-cubism/node_modules/cubism/src/rule.js":"cubism_contextPrototype.rule = function() {\n  var context = this,\n      metric = cubism_identity;\n\n  function rule(selection) {\n    var id = ++cubism_id;\n\n    var line = selection.append(\"div\")\n        .datum({id: id})\n        .attr(\"class\", \"line\")\n        .call(cubism_ruleStyle);\n\n    selection.each(function(d, i) {\n      var that = this,\n          id = ++cubism_id,\n          metric_ = typeof metric === \"function\" ? metric.call(that, d, i) : metric;\n\n      if (!metric_) return;\n\n      function change(start, stop) {\n        var values = [];\n\n        for (var i = 0, n = context.size(); i < n; ++i) {\n          if (metric_.valueAt(i)) {\n            values.push(i);\n          }\n        }\n\n        var lines = selection.selectAll(\".metric\").data(values);\n        lines.exit().remove();\n        lines.enter().append(\"div\").attr(\"class\", \"metric line\").call(cubism_ruleStyle);\n        lines.style(\"left\", cubism_ruleLeft);\n      }\n\n      context.on(\"change.rule-\" + id, change);\n      metric_.on(\"change.rule-\" + id, change);\n    });\n\n    context.on(\"focus.rule-\" + id, function(i) {\n      line.datum(i)\n          .style(\"display\", i == null ? \"none\" : null)\n          .style(\"left\", i == null ? null : cubism_ruleLeft);\n    });\n  }\n\n  rule.remove = function(selection) {\n\n    selection.selectAll(\".line\")\n        .each(remove)\n        .remove();\n\n    function remove(d) {\n      context.on(\"focus.rule-\" + d.id, null);\n    }\n  };\n\n  rule.metric = function(_) {\n    if (!arguments.length) return metric;\n    metric = _;\n    return rule;\n  };\n\n  return rule;\n};\n\nfunction cubism_ruleStyle(line) {\n  line\n      .style(\"position\", \"absolute\")\n      .style(\"top\", 0)\n      .style(\"bottom\", 0)\n      .style(\"width\", \"1px\")\n      .style(\"pointer-events\", \"none\");\n}\n\nfunction cubism_ruleLeft(i) {\n  return i + \"px\";\n}\n"}